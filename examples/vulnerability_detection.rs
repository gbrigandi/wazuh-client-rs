//! Vulnerability detection example for the Wazuh Rust client
//!
//! This example demonstrates:
//! - Comprehensive vulnerability scanning and assessment
//! - Package inventory and security analysis
//! - Process monitoring and threat detection
//! - Network port analysis and security assessment
//! - Risk prioritization and remediation guidance

use log::debug;
use std::collections::HashMap;
use std::env;
use tracing::{error, trace, warn};
use wazuh_client::WazuhClientFactory;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    trace!("Starting example execution");

    println!("🔍 Wazuh Rust Client - Vulnerability Detection Example");
    println!("======================================================");

    let factory = create_client_factory();

    trace!("Testing connectivity");
    println!("🔍 Testing connectivity...");
    let connectivity = factory.test_connectivity().await?;
    if !connectivity.api_connected {
        error!(
            "❌ Cannot connect to Wazuh API: {}",
            connectivity.api_error.as_deref().unwrap_or("Unknown error")
        );
        return Err("API connectivity failed".into());
    }
    println!("✅ Connected to Wazuh API");

    let mut vulnerability_client = factory.create_vulnerability_client();
    let mut agents_client = factory.create_agents_client();

    println!("\n🤖 Agent Selection for Vulnerability Scanning");
    println!("==============================================");

    let agents = agents_client.get_active_agents().await?;

    if agents.is_empty() {
        println!("❌ No active agents found for vulnerability scanning");
        return Ok(());
    }

    println!("✅ Found {} active agents for scanning", agents.len());
    for agent in agents.iter().take(5) {
        println!(
            "   🔹 Agent {}: {} ({})",
            agent.id,
            agent.name,
            agent.ip.as_deref().unwrap_or("N/A")
        );
    }

    let target_agent = &agents[0];
    println!(
        "\n🎯 Focusing on agent: {} ({})",
        target_agent.name, target_agent.id
    );

    println!("\n🚨 Vulnerability Assessment");
    println!("===========================");

    match vulnerability_client
        .get_agent_vulnerabilities(
            &target_agent.id,
            Some(50), // limit
            None,     // offset
            None,     // severity filter
        )
        .await
    {
        Ok(vulnerabilities) => {
            if vulnerabilities.is_empty() {
                println!(
                    "✅ No vulnerabilities found for agent {}",
                    target_agent.name
                );
            } else {
                println!(
                    "⚠️  Found {} vulnerabilities for agent {}",
                    vulnerabilities.len(),
                    target_agent.name
                );

                // Analyze vulnerabilities by severity
                let mut severity_counts: HashMap<String, u32> = HashMap::new();
                let mut cvss_scores: Vec<f64> = Vec::new();

                for vuln in &vulnerabilities {
                    *severity_counts.entry(vuln.severity.clone()).or_insert(0) += 1;

                    if let Some(cvss) = &vuln.cvss {
                        if let Some(cvss3) = &cvss.cvss3 {
                            if let Some(score) = cvss3.base_score {
                                cvss_scores.push(score);
                            }
                        } else if let Some(cvss2) = &cvss.cvss2 {
                            if let Some(score) = cvss2.base_score {
                                cvss_scores.push(score);
                            }
                        }
                    }
                }

                println!("\n📊 Vulnerability Distribution:");
                for (severity, count) in &severity_counts {
                    println!("   {}: {} vulnerabilities", severity, count);
                }

                if !cvss_scores.is_empty() {
                    let avg_score = cvss_scores.iter().sum::<f64>() / cvss_scores.len() as f64;
                    let max_score = cvss_scores.iter().fold(0.0f64, |a, &b| a.max(b));
                    println!("\n📈 CVSS Score Analysis:");
                    println!("   Average CVSS Score: {:.1}", avg_score);
                    println!("   Highest CVSS Score: {:.1}", max_score);
                }

                // Show top 10 most critical vulnerabilities
                println!("\n🔥 Top Critical Vulnerabilities:");
                for vuln in vulnerabilities.iter().take(10) {
                    println!("   🔹 {}: {}", vuln.cve, vuln.title);
                    println!(
                        "      Severity: {} | Published: {}",
                        vuln.severity,
                        vuln.published.as_deref().unwrap_or("Unknown")
                    );

                    if let Some(cvss) = &vuln.cvss {
                        if let Some(cvss3) = &cvss.cvss3 {
                            if let Some(score) = cvss3.base_score {
                                println!("      CVSS v3 Score: {:.1}", score);
                            }
                        }
                    }

                    if let Some(desc) = &vuln.description {
                        let short_desc = if desc.len() > 100 {
                            format!("{}...", &desc[..100])
                        } else {
                            desc.clone()
                        };
                        println!("      Description: {}", short_desc);
                    }
                    println!();
                }
            }
        }
        Err(e) => warn!("Failed to get vulnerabilities: {}", e),
    }

    println!("\n🚨 Critical Vulnerability Analysis");
    println!("==================================");

    match vulnerability_client
        .get_critical_vulnerabilities(&target_agent.id)
        .await
    {
        Ok(critical_vulns) => {
            println!("🔥 Critical vulnerabilities: {}", critical_vulns.len());
            for vuln in critical_vulns.iter().take(5) {
                println!("   ⚠️  {}: {}", vuln.cve, vuln.title);
                if let Some(ref_url) = &vuln.reference {
                    println!("      Reference: {}", ref_url);
                }
            }
        }
        Err(e) => {
            if e.to_string().contains("status 404 Not Found") {
                warn!(
                    "Failed to get critical vulnerabilities: {}. This might indicate that vulnerability data is not available for this agent.",
                    e
                );
            } else {
                warn!("Failed to get critical vulnerabilities: {}", e);
            }
        }
    }

    match vulnerability_client
        .get_high_vulnerabilities(&target_agent.id)
        .await
    {
        Ok(high_vulns) => {
            println!("\n⚠️  High severity vulnerabilities: {}", high_vulns.len());
            for vuln in high_vulns.iter().take(5) {
                println!("   • {}: {}", vuln.cve, vuln.title);
            }
        }
        Err(e) => {
            if e.to_string().contains("status 404 Not Found") {
                warn!(
                    "Failed to get high vulnerabilities: {}. This might indicate that vulnerability data is not available for this agent.",
                    e
                );
            } else {
                warn!("Failed to get high vulnerabilities: {}", e);
            }
        }
    }

    println!("\n📦 Package Inventory Analysis");
    println!("=============================");

    match vulnerability_client
        .get_agent_packages(
            &target_agent.id,
            Some(20), // limit
            None,     // offset
            None,     // search
        )
        .await
    {
        Ok(packages) => {
            println!("📋 Installed packages: {}", packages.len());

            // Analyze packages by format/type
            let mut format_counts: HashMap<String, u32> = HashMap::new();
            let mut vendor_counts: HashMap<String, u32> = HashMap::new();

            for package in &packages {
                if let Some(format) = &package.format {
                    *format_counts.entry(format.clone()).or_insert(0) += 1;
                }
                if let Some(vendor) = &package.vendor {
                    *vendor_counts.entry(vendor.clone()).or_insert(0) += 1;
                }
            }

            println!("\n📊 Package Distribution by Format:");
            for (format, count) in &format_counts {
                println!("   {}: {} packages", format, count);
            }

            println!("\n🏢 Top Package Vendors:");
            let mut sorted_vendors: Vec<_> = vendor_counts.iter().collect();
            sorted_vendors.sort_by_key(|(_, count)| std::cmp::Reverse(**count));
            for (vendor, count) in sorted_vendors.iter().take(5) {
                println!("   {}: {} packages", vendor, count);
            }

            // Show sample packages
            println!("\n📦 Sample Installed Packages:");
            for package in packages.iter().take(10) {
                println!("   🔹 {} v{}", package.name, package.version);
                println!(
                    "      Architecture: {} | Format: {}",
                    package.architecture.as_deref().unwrap_or("Unknown"),
                    package.format.as_deref().unwrap_or("Unknown")
                );
                if let Some(desc) = &package.description {
                    let short_desc = if desc.len() > 80 {
                        format!("{}...", &desc[..80])
                    } else {
                        desc.clone()
                    };
                    println!("      Description: {}", short_desc);
                }
                println!();
            }
        }
        Err(e) => warn!("Failed to get packages: {}", e),
    }

    println!("\n⚙️  Process Analysis");
    println!("====================");

    match vulnerability_client
        .get_agent_processes(
            &target_agent.id,
            Some(15), // limit
            None,     // offset
            None,     // search
        )
        .await
    {
        Ok(processes) => {
            println!("🔄 Running processes: {}", processes.len());

            // Analyze processes by state and resource usage
            let mut state_counts: HashMap<String, u32> = HashMap::new();
            let mut high_memory_processes = Vec::new();

            for process in &processes {
                if let Some(state) = &process.state {
                    *state_counts.entry(state.clone()).or_insert(0) += 1;
                }

                if let Some(vm_size) = process.vm_size {
                    if vm_size > 1024 * 1024 * 100 {
                        // > 100MB
                        high_memory_processes.push(process);
                    }
                }
            }

            println!("\n📊 Process States:");
            for (state, count) in &state_counts {
                println!("   {}: {} processes", state, count);
            }

            if !high_memory_processes.is_empty() {
                println!("\n🧠 High Memory Usage Processes:");
                for process in high_memory_processes.iter().take(5) {
                    let memory_mb = process.vm_size.unwrap_or(0) / (1024 * 1024);
                    println!(
                        "   🔹 {} (PID: {}): {} MB",
                        process.name, process.pid, memory_mb
                    );
                    if let Some(cmd) = &process.cmd {
                        let short_cmd = if cmd.len() > 60 {
                            format!("{}...", &cmd[..60])
                        } else {
                            cmd.clone()
                        };
                        println!("      Command: {}", short_cmd);
                    }
                }
            }

            // Show sample processes
            println!("\n⚙️  Sample Running Processes:");
            for process in processes.iter().take(8) {
                println!("   🔹 {} (PID: {})", process.name, process.pid);
                println!(
                    "      State: {} | User: {}",
                    process.state.as_deref().unwrap_or("Unknown"),
                    process.euser.as_deref().unwrap_or("Unknown")
                );
                if let Some(start_time) = &process.start_time {
                    println!("      Started: {}", start_time);
                }
                println!();
            }
        }
        Err(e) => warn!("Failed to get processes: {}", e),
    }

    println!("\n🌐 Network Port Analysis");
    println!("========================");

    match vulnerability_client
        .get_agent_ports(
            &target_agent.id,
            Some(20), // limit
            None,     // offset
            None,     // protocol filter
        )
        .await
    {
        Ok(ports) => {
            println!("🔌 Open ports: {}", ports.len());

            // Analyze ports by protocol and state
            let mut protocol_counts: HashMap<String, u32> = HashMap::new();
            let mut state_counts: HashMap<String, u32> = HashMap::new();
            let mut listening_ports = Vec::new();

            for port in &ports {
                *protocol_counts.entry(port.protocol.clone()).or_insert(0) += 1;
                if let Some(state) = &port.state {
                    *state_counts.entry(state.clone()).or_insert(0) += 1;
                }

                if port.state.as_deref() == Some("listening") {
                    listening_ports.push(port);
                }
            }

            println!("\n📊 Port Distribution:");
            println!("   By Protocol:");
            for (protocol, count) in &protocol_counts {
                println!("     {}: {} ports", protocol, count);
            }
            println!("   By State:");
            for (state, count) in &state_counts {
                println!("     {}: {} ports", state, count);
            }

            if !listening_ports.is_empty() {
                println!("\n👂 Listening Ports (Security Focus):");
                for port in listening_ports.iter().take(10) {
                    println!(
                        "   🔹 {}:{} ({})",
                        port.local.ip, port.local.port, port.protocol
                    );
                    println!(
                        "      State: {} | Process: {}",
                        port.state.as_deref().unwrap_or("N/A"),
                        port.process.as_deref().unwrap_or("Unknown")
                    );
                    if let Some(pid) = port.pid {
                        println!("      PID: {}", pid);
                    }
                    println!();
                }
            }
        }
        Err(e) => warn!("Failed to get ports: {}", e),
    }

    println!("\n📊 Vulnerability Summary");
    println!("========================");

    match vulnerability_client
        .get_vulnerability_summary(&target_agent.id)
        .await
    {
        Ok(summary) => {
            println!("📈 Vulnerability Summary for {}:", target_agent.name);
            // The summary is a raw serde_json::Value, print it prettily
            if let Ok(pretty_summary) = serde_json::to_string_pretty(&summary) {
                println!("   Summary:\n{}", pretty_summary);
            } else {
                println!("   Summary: {:?}", summary); // Fallback to debug print
            }
        }
        Err(e) => {
            if e.to_string().contains("status 404 Not Found") {
                // Changed from warn! to info! for less alarming output on common "no data" scenario
                tracing::info!(
                    "Failed to get vulnerability summary: {}. This might indicate that vulnerability data is not available for this agent, or the vulnerability detector hasn't run yet.",
                    e
                );
            } else {
                warn!("Failed to get vulnerability summary: {}", e); // Keep warn for other unexpected errors
            }
        }
    }

    println!("\n🔍 Package Search Examples");
    println!("==========================");

    let search_packages = vec!["openssl", "apache", "nginx", "ssh"];

    for package_name in search_packages {
        match vulnerability_client
            .search_package(package_name, Some(&[target_agent.id.clone()]))
            .await
        {
            Ok(search_results) => {
                if !search_results.is_empty() {
                    println!(
                        "🔍 Found '{}' package: {} instances",
                        package_name,
                        search_results.len()
                    );
                    for (agent_id, packages) in search_results.iter().take(2) {
                        println!("   Agent ID: {}", agent_id);
                        if packages.is_empty() {
                            println!(
                                "     No instances of '{}' found on this agent.",
                                package_name
                            );
                        } else {
                            for package in packages.iter().take(3) {
                                // Show details for up to 3 packages
                                println!("     📦 {} v{}", package.name, package.version);
                                if let Some(arch) = &package.architecture {
                                    println!("        Architecture: {}", arch);
                                }
                                if let Some(format) = &package.format {
                                    println!("        Format: {}", format);
                                }
                                if let Some(vendor) = &package.vendor {
                                    println!("        Vendor: {}", vendor);
                                }
                                if let Some(desc) = &package.description {
                                    let short_desc = if desc.len() > 70 {
                                        // Adjusted length
                                        format!("{}...", &desc[..70])
                                    } else {
                                        desc.clone()
                                    };
                                    println!("        Description: {}", short_desc);
                                }
                                println!(); // Blank line for separation
                            }
                            if packages.len() > 3 {
                                println!(
                                    "        ... and {} more package(s) found on this agent.",
                                    packages.len() - 3
                                );
                                println!();
                            }
                        }
                    }
                } else {
                    debug!(
                        "No instances of '{}' package found for agent {}",
                        package_name, target_agent.id
                    );
                }
            }
            Err(e) => warn!("Failed to search for package '{}': {}", package_name, e),
        }
    }

    Ok(())
}

fn create_client_factory() -> WazuhClientFactory {
    let api_host = env::var("WAZUH_API_HOST").unwrap_or_else(|_| "localhost".to_string());
    let api_port: u16 = env::var("WAZUH_API_PORT")
        .unwrap_or_else(|_| "55000".to_string())
        .parse()
        .unwrap_or(55000);
    let api_username = env::var("WAZUH_API_USERNAME").unwrap_or_else(|_| "wazuh".to_string());
    let api_password = env::var("WAZUH_API_PASSWORD").unwrap_or_else(|_| "wazuh".to_string());

    let indexer_host = env::var("WAZUH_INDEXER_HOST").unwrap_or_else(|_| "localhost".to_string());
    let indexer_port: u16 = env::var("WAZUH_INDEXER_PORT")
        .unwrap_or_else(|_| "9200".to_string())
        .parse()
        .unwrap_or(9200);
    let indexer_username =
        env::var("WAZUH_INDEXER_USERNAME").unwrap_or_else(|_| "admin".to_string());
    let indexer_password =
        env::var("WAZUH_INDEXER_PASSWORD").unwrap_or_else(|_| "admin".to_string());

    let verify_ssl = env::var("WAZUH_VERIFY_SSL")
        .unwrap_or_else(|_| "false".to_string())
        .parse()
        .unwrap_or(false);

    WazuhClientFactory::new(
        api_host,
        api_port,
        api_username,
        api_password,
        indexer_host,
        indexer_port,
        indexer_username,
        indexer_password,
        verify_ssl,
        Some("https".to_string()),
    )
}
