use reqwest::Method;
use serde::{Deserialize, Serialize};
use tracing::{debug, info};

use super::wazuh_client::WazuhApiClient;

mod string_or_number_as_string {
    use serde::{Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<String, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum StringOrNumber {
            Str(String),
            Num(serde_json::Number),
        }

        match StringOrNumber::deserialize(deserializer)? {
            StringOrNumber::Str(s) => Ok(s),
            StringOrNumber::Num(n) => Ok(n.to_string()),
        }
    }

    pub fn deserialize_optional<'de, D>(deserializer: D) -> Result<Option<String>, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum StringOrNumberOrNull {
            Str(String),
            Num(serde_json::Number),
        }

        let intermediate: Option<StringOrNumberOrNull> = Option::deserialize(deserializer)?;

        match intermediate {
            Some(StringOrNumberOrNull::Str(s)) => Ok(Some(s)),
            Some(StringOrNumberOrNull::Num(n)) => Ok(Some(n.to_string())),
            None => Ok(None),
        }
    }
}
use super::error::WazuhApiError;

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Vulnerability {
    pub cve: String,
    pub title: String,
    pub severity: String,
    pub published: Option<String>,
    pub updated: Option<String>,
    pub reference: Option<String>,
    pub description: Option<String>,
    pub cvss: Option<CvssScore>,
    pub detection_time: Option<String>,
    pub agent_id: Option<String>,
    pub agent_name: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct CvssScore {
    pub cvss2: Option<CvssDetails>,
    pub cvss3: Option<CvssDetails>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct CvssDetails {
    pub vector: Option<String>,
    pub base_score: Option<f64>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Package {
    pub name: String,
    pub version: String,
    pub architecture: Option<String>,
    pub format: Option<String>,
    pub description: Option<String>,
    pub size: Option<u64>,
    pub vendor: Option<String>,
    pub multiarch: Option<String>,
    pub source: Option<String>,
    pub priority: Option<String>,
    pub scan_id: Option<u64>,
    pub section: Option<String>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Process {
    #[serde(deserialize_with = "string_or_number_as_string::deserialize")]
    pub pid: String,
    pub name: String,
    pub state: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub ppid: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub utime: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub stime: Option<String>,
    pub cmd: Option<String>,
    pub argvs: Option<String>,
    pub euser: Option<String>,
    pub ruser: Option<String>,
    pub suser: Option<String>,
    pub egroup: Option<String>,
    pub rgroup: Option<String>,
    pub sgroup: Option<String>,
    pub fgroup: Option<String>,
    pub priority: Option<i32>,
    pub nice: Option<i32>,
    pub size: Option<u64>,
    pub vm_size: Option<u64>,
    pub resident: Option<u64>,
    pub share: Option<u64>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub start_time: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub pgrp: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub session: Option<String>,
    pub nlwp: Option<u32>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub tgid: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub tty: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub processor: Option<String>,
    pub scan_id: Option<u64>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Port {
    pub local: PortInfo,
    pub remote: Option<PortInfo>,
    pub state: Option<String>,
    pub protocol: String,
    pub tx_queue: Option<u32>,
    pub rx_queue: Option<u32>,
    pub inode: Option<u64>,
    pub process: Option<String>,
    pub scan_id: Option<u64>,
    pub agent_id: Option<String>,
    pub pid: Option<u32>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct VulnerabilitySummaryCounts {
    pub critical: i32,
    pub high: i32,
    pub medium: i32,
    pub low: i32,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct VulnerabilitySummaryResponseData {
    pub agent_id: String,
    pub summary: VulnerabilitySummaryCounts,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct PortInfo {
    pub ip: String,
    pub port: u16,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityClient {
    api_client: WazuhApiClient,
}

impl VulnerabilityClient {
    pub fn new(api_client: WazuhApiClient) -> Self {
        Self { api_client }
    }

    pub async fn get_agent_vulnerabilities(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        severity: Option<&str>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, ?severity, "Getting vulnerabilities for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(severity) = severity {
            query_params.push(("severity", severity.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/vulnerability/{}", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let vulns_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in vulnerabilities response".to_string(),
                )
            })?;

        let vulnerabilities: Vec<Vulnerability> = serde_json::from_value(vulns_data.clone())?;
        info!(%agent_id, "Retrieved {} vulnerabilities", vulnerabilities.len());
        Ok(vulnerabilities)
    }

    pub async fn get_critical_vulnerabilities(
        &mut self,
        agent_id: &str,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, "Getting critical vulnerabilities");
        self.get_agent_vulnerabilities(agent_id, None, None, Some("Critical"))
            .await
    }

    pub async fn get_high_vulnerabilities(
        &mut self,
        agent_id: &str,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, "Getting high severity vulnerabilities");
        self.get_agent_vulnerabilities(agent_id, None, None, Some("High"))
            .await
    }

    pub async fn get_agent_packages(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        search: Option<&str>,
    ) -> Result<Vec<Package>, WazuhApiError> {
        debug!(%agent_id, ?search, "Getting packages for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(search) = search {
            query_params.push(("search", search.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/packages", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let packages_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in packages response".to_string(),
                )
            })?;

        let packages: Vec<Package> = serde_json::from_value(packages_data.clone())?;
        info!(%agent_id, "Retrieved {} packages", packages.len());
        Ok(packages)
    }

    pub async fn get_agent_processes(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        search: Option<&str>,
    ) -> Result<Vec<Process>, WazuhApiError> {
        debug!(%agent_id, ?search, "Getting processes for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(search) = search {
            query_params.push(("search", search.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/processes", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let processes_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in processes response".to_string(),
                )
            })?;

        let processes: Vec<Process> = serde_json::from_value(processes_data.clone())?;
        info!(%agent_id, "Retrieved {} processes", processes.len());
        Ok(processes)
    }

    pub async fn get_agent_ports(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        protocol: Option<&str>,
    ) -> Result<Vec<Port>, WazuhApiError> {
        debug!(%agent_id, ?protocol, "Getting ports for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(protocol) = protocol {
            query_params.push(("protocol", protocol.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/ports", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let ports_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in ports response".to_string(),
                )
            })?;

        let ports: Vec<Port> = serde_json::from_value(ports_data.clone())?;
        info!(%agent_id, "Retrieved {} ports", ports.len());
        Ok(ports)
    }

    pub async fn get_vulnerability_summary(
        &mut self,
        agent_id: &str,
    ) -> Result<Option<VulnerabilitySummaryResponseData>, WazuhApiError> {
        debug!(%agent_id, "Getting vulnerability summary");
        let endpoint = format!("/vulnerability/{}/summary", agent_id);

        match self
            .api_client
            .make_request(Method::GET, &endpoint, None, None)
            .await
        {
            Ok(response_value) => {
                let data_field = response_value.get("data").ok_or_else(|| {
                    WazuhApiError::ApiError(
                        "Missing 'data' field in vulnerability summary response".to_string(),
                    )
                })?;

                let summary_data: VulnerabilitySummaryResponseData =
                    serde_json::from_value(data_field.clone())?;

                info!(%agent_id, "Retrieved vulnerability summary");
                Ok(Some(summary_data))
            }
            Err(e) => {
                if let WazuhApiError::HttpError { status, .. } = &e {
                    if *status == reqwest::StatusCode::NOT_FOUND {
                        info!(
                            %agent_id,
                            "Vulnerability summary not found (404). Agent might not have data or detector hasn't run."
                        );
                        return Ok(None);
                    }
                }
                Err(e)
            }
        }
    }

    pub async fn search_package(
        &mut self,
        package_name: &str,
        agent_ids: Option<&[String]>,
    ) -> Result<Vec<(String, Vec<Package>)>, WazuhApiError> {
        debug!(%package_name, "Searching for package across agents");

        let mut results = Vec::new();

        if let Some(agent_ids) = agent_ids {
            for agent_id in agent_ids {
                match self
                    .get_agent_packages(agent_id, None, None, Some(package_name))
                    .await
                {
                    Ok(packages) => {
                        if !packages.is_empty() {
                            results.push((agent_id.clone(), packages));
                        }
                    }
                    Err(e) => {
                        debug!(%agent_id, %package_name, "Failed to get packages: {}", e);
                    }
                }
            }
        }

        info!(%package_name, "Found package in {} agents", results.len());
        Ok(results)
    }

    pub async fn get_agents_with_vulnerability(
        &mut self,
        cve: &str,
        agent_ids: &[String],
    ) -> Result<Vec<String>, WazuhApiError> {
        debug!(%cve, "Finding agents with specific vulnerability");

        let mut affected_agents = Vec::new();

        for agent_id in agent_ids {
            match self
                .get_agent_vulnerabilities(agent_id, None, None, None)
                .await
            {
                Ok(vulnerabilities) => {
                    if vulnerabilities.iter().any(|v| v.cve == cve) {
                        affected_agents.push(agent_id.clone());
                    }
                }
                Err(e) => {
                    debug!(%agent_id, %cve, "Failed to get vulnerabilities: {}", e);
                }
            }
        }

        info!(%cve, "Found {} agents with vulnerability", affected_agents.len());
        Ok(affected_agents)
    }
}
